File Name: agent.py

-----------------------------

File Content: 

import sqlite3
import requests
from typing import Dict, Any, List
from pydantic import BaseModel, Field
from langchain_core.messages import BaseMessage, HumanMessage, SystemMessage, AIMessage
from langchain_anthropic import ChatAnthropic
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.prebuilt import create_react_agent
from langchain_core.tools import tool
from langchain_core.runnables import RunnableConfig


class SqlQuery(BaseModel):
    """Structured output for SQL query generation"""
    query: str = Field(description="The SQL query to execute")
    reasoning: str = Field(description="Explanation of why this query answers the question")


class DatabaseSchema:
    """Manages the Chinook database schema and connection"""
    
    def __init__(self):
        self.connection = None
        self.schema_info = self._get_schema_info()
        self._setup_database()
    
    def _setup_database(self):
        """Download and setup the Chinook database in memory"""
        try:
            # Fetch the SQL script
            response = requests.get("https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql")
            response.raise_for_status()
            sql_script = response.text
            
            # Create in-memory database
            self.connection = sqlite3.connect(":memory:")
            self.connection.executescript(sql_script)
            self.connection.commit()
            
        except Exception as e:
            raise Exception(f"Failed to setup Chinook database: {e}")
    
    def _get_schema_info(self) -> str:
        """Returns detailed schema information for the AI model"""
        return """
CHINOOK DATABASE SCHEMA:

Tables and Relationships:

1. Artist
   - ArtistId (INTEGER, PRIMARY KEY)
   - Name (NVARCHAR)

2. Album  
   - AlbumId (INTEGER, PRIMARY KEY)
   - Title (NVARCHAR)
   - ArtistId (INTEGER, FOREIGN KEY -> Artist.ArtistId)

3. Track
   - TrackId (INTEGER, PRIMARY KEY)
   - Name (NVARCHAR)
   - AlbumId (INTEGER, FOREIGN KEY -> Album.AlbumId)
   - MediaTypeId (INTEGER, FOREIGN KEY -> MediaType.MediaTypeId)
   - GenreId (INTEGER, FOREIGN KEY -> Genre.GenreId)
   - Composer (NVARCHAR)
   - Milliseconds (INTEGER)
   - Bytes (INTEGER) 
   - UnitPrice (NUMERIC)

4. Genre
   - GenreId (INTEGER, PRIMARY KEY)
   - Name (NVARCHAR)

5. MediaType
   - MediaTypeId (INTEGER, PRIMARY KEY)
   - Name (NVARCHAR)

6. Playlist
   - PlaylistId (INTEGER, PRIMARY KEY)
   - Name (NVARCHAR)

7. PlaylistTrack
   - PlaylistId (INTEGER, FOREIGN KEY -> Playlist.PlaylistId)
   - TrackId (INTEGER, FOREIGN KEY -> Track.TrackId)

8. Customer
   - CustomerId (INTEGER, PRIMARY KEY)
   - FirstName (NVARCHAR)
   - LastName (NVARCHAR)
   - Company (NVARCHAR)
   - Address (NVARCHAR)
   - City (NVARCHAR)
   - State (NVARCHAR)
   - Country (NVARCHAR)
   - PostalCode (NVARCHAR)
   - Phone (NVARCHAR)
   - Fax (NVARCHAR)
   - Email (NVARCHAR)
   - SupportRepId (INTEGER, FOREIGN KEY -> Employee.EmployeeId)

9. Employee
   - EmployeeId (INTEGER, PRIMARY KEY)
   - LastName (NVARCHAR)
   - FirstName (NVARCHAR)
   - Title (NVARCHAR)
   - ReportsTo (INTEGER, FOREIGN KEY -> Employee.EmployeeId)
   - BirthDate (DATETIME)
   - HireDate (DATETIME)
   - Address (NVARCHAR)
   - City (NVARCHAR)
   - State (NVARCHAR)
   - Country (NVARCHAR)
   - PostalCode (NVARCHAR)
   - Phone (NVARCHAR)
   - Fax (NVARCHAR)
   - Email (NVARCHAR)

10. Invoice
    - InvoiceId (INTEGER, PRIMARY KEY)
    - CustomerId (INTEGER, FOREIGN KEY -> Customer.CustomerId)
    - InvoiceDate (DATETIME)
    - BillingAddress (NVARCHAR)
    - BillingCity (NVARCHAR)
    - BillingState (NVARCHAR)
    - BillingCountry (NVARCHAR)
    - BillingPostalCode (NVARCHAR)
    - Total (NUMERIC)

11. InvoiceLine
    - InvoiceLineId (INTEGER, PRIMARY KEY)
    - InvoiceId (INTEGER, FOREIGN KEY -> Invoice.InvoiceId)
    - TrackId (INTEGER, FOREIGN KEY -> Track.TrackId)
    - UnitPrice (NUMERIC)
    - Quantity (INTEGER)

Key Business Relationships:
- Artists have Albums, Albums have Tracks
- Customers make Purchases (Invoices) containing InvoiceLines
- Tracks belong to Genres and MediaTypes
- Employees can be assigned as Support Representatives to Customers
- Playlists contain multiple Tracks through PlaylistTrack junction table
"""

    def execute_query(self, query: str) -> List[Dict[str, Any]]:
        """Execute SQL query and return results as list of dictionaries"""
        try:
            cursor = self.connection.cursor()
            cursor.execute(query)
            columns = [description[0] for description in cursor.description]
            results = []
            for row in cursor.fetchall():
                results.append(dict(zip(columns, row)))
            return results
        except Exception as e:
            raise Exception(f"SQL execution error: {e}")


# Initialize database
db = DatabaseSchema()

@tool
def execute_sql_query(query: str) -> str:
    """Execute a SQL query against the Chinook database and return results.
    
    Args:
        query: The SQL query to execute
        
    Returns:
        String representation of query results
    """
    try:
        results = db.execute_query(query)
        if not results:
            return "No results found."
        
        # Format results for display
        if len(results) == 1:
            return f"Result: {results[0]}"
        else:
            formatted_results = []
            for i, result in enumerate(results[:10]):  # Limit to first 10 results
                formatted_results.append(f"{i+1}. {result}")
            
            result_str = "\n".join(formatted_results)
            if len(results) > 10:
                result_str += f"\n... and {len(results) - 10} more results"
            
            return result_str
            
    except Exception as e:
        return f"Error executing query: {str(e)}"


def create_text_to_sql_agent():
    """Create a text-to-SQL agent using LangGraph"""
    
    # Initialize the model
    model = ChatAnthropic(model="claude-3-5-sonnet-20241022")
    
    # Create system prompt with schema information
    system_prompt = f"""You are a text-to-SQL assistant for the Chinook music database. Your job is to:

1. Convert natural language questions into SQL queries
2. Execute those queries against the database  
3. Provide natural language responses based on the results

{db.schema_info}

IMPORTANT RULES:
- ONLY answer questions that can be answered using the Chinook database
- If a question cannot be answered with the available data, respond: "I don't know the answer to that question."
- Always use proper SQL syntax for SQLite
- Be precise with table and column names
- Use JOINs when querying across multiple tables
- Limit results to reasonable numbers (use LIMIT clause when appropriate)
- Provide clear, natural language explanations of your findings

When you receive a question:
1. Determine if it can be answered using the Chinook database
2. If yes, generate and execute the appropriate SQL query using the execute_sql_query tool
3. Interpret the results and provide a natural language response
4. If no, respond that you don't know the answer"""

    # Create the agent using prebuilt create_react_agent
    agent = create_react_agent(
        model=model,
        tools=[execute_sql_query],
        prompt=system_prompt
    )
    
    return agent


# Create and export the app
app = create_text_to_sql_agent()



File Name: demo.py

-----------------------------

File Content: 

#!/usr/bin/env python3

from agent import db, execute_sql_query

def demonstrate_sql_capabilities():
    """Demonstrate the SQL generation and execution capabilities"""
    
    print("üéµ Chinook Database Text-to-SQL Agent Demo üéµ")
    print("=" * 50)
    
    # Sample natural language questions and their corresponding SQL
    demonstrations = [
        {
            "question": "How many artists are in the database?",
            "sql": "SELECT COUNT(*) as artist_count FROM Artist",
            "explanation": "Simple count query to get total number of artists"
        },
        {
            "question": "What are the top 5 most expensive tracks?",
            "sql": "SELECT Name, UnitPrice FROM Track ORDER BY UnitPrice DESC LIMIT 5",
            "explanation": "Query to find tracks with highest unit price"
        },
        {
            "question": "Which rock albums are available?",
            "sql": """SELECT DISTINCT a.Title, ar.Name as Artist 
                     FROM Album a 
                     JOIN Artist ar ON a.ArtistId = ar.ArtistId
                     JOIN Track t ON a.AlbumId = t.AlbumId
                     JOIN Genre g ON t.GenreId = g.GenreId 
                     WHERE g.Name = 'Rock' 
                     LIMIT 10""",
            "explanation": "Complex join to find rock albums using genre information"
        },
        {
            "question": "What are all the available genres?",
            "sql": "SELECT Name FROM Genre ORDER BY Name",
            "explanation": "Simple query to list all music genres"
        },
        {
            "question": "Which customers are from Canada?",
            "sql": "SELECT FirstName, LastName, City FROM Customer WHERE Country = 'Canada'",
            "explanation": "Filter customers by country"
        }
    ]
    
    for i, demo in enumerate(demonstrations, 1):
        print(f"\nüìù Example {i}: {demo['question']}")
        print(f"üí° SQL Translation: {demo['sql'].strip()}")
        print(f"üîç Explanation: {demo['explanation']}")
        print("üìä Results:")
        
        try:
            result = execute_sql_query.func(demo['sql'].strip())
            print(f"   {result}")
        except Exception as e:
            print(f"   Error: {e}")
        
        print("-" * 50)
    
    print("\n‚úÖ Database Statistics:")
    print(f"   ‚Ä¢ Artists: {len(db.execute_query('SELECT * FROM Artist'))}")
    print(f"   ‚Ä¢ Albums: {len(db.execute_query('SELECT * FROM Album'))}")
    print(f"   ‚Ä¢ Tracks: {len(db.execute_query('SELECT * FROM Track'))}")
    print(f"   ‚Ä¢ Genres: {len(db.execute_query('SELECT * FROM Genre'))}")
    print(f"   ‚Ä¢ Customers: {len(db.execute_query('SELECT * FROM Customer'))}")
    
    print("\nüöÄ To use the full agent with natural language processing:")
    print("   1. Set up your ANTHROPIC_API_KEY in .env file")
    print("   2. Run: python test_agent.py")
    print("\nüí° The agent will automatically:")
    print("   ‚Ä¢ Convert natural language to SQL")
    print("   ‚Ä¢ Execute queries safely")
    print("   ‚Ä¢ Return natural language responses")
    print("   ‚Ä¢ Handle irrelevant questions appropriately")

if __name__ == "__main__":
    demonstrate_sql_capabilities()



File Name: langgraph.json

-----------------------------

File Content: 

{
  "dependencies": [
    "langgraph",
    "langchain-anthropic", 
    "langchain-core",
    "pydantic",
    "requests",
    "sqlite3"
  ],
  "graphs": {
    "text_to_sql_agent": "./agent.py:app"
  },
  "env": ".env"
}



File Name: test_agent.py

-----------------------------

File Content: 

#!/usr/bin/env python3

import os
from agent import app

def test_agent():
    """Test the text-to-SQL agent with sample questions"""
    
    test_questions = [
        "How many artists are in the database?",
        "What are the top 5 most expensive tracks?",
        "Which customers are from the USA?",
        "What is the weather like today?",  # Should respond with "I don't know"
        "Show me all genres available in the database"
    ]
    
    print("Testing Text-to-SQL Agent")
    print("=" * 50)
    
    for i, question in enumerate(test_questions, 1):
        print(f"\nTest {i}: {question}")
        print("-" * 30)
        
        try:
            # Invoke the agent
            result = app.invoke({
                "messages": [{"role": "user", "content": question}]
            })
            
            # Extract the final response
            if result and "messages" in result:
                final_message = result["messages"][-1]
                if hasattr(final_message, 'content'):
                    print(f"Response: {final_message.content}")
                else:
                    print(f"Response: {final_message}")
            else:
                print(f"Unexpected result format: {result}")
                
        except Exception as e:
            print(f"Error: {str(e)}")

if __name__ == "__main__":
    test_agent()



File Name: test_database.py

-----------------------------

File Content: 

#!/usr/bin/env python3

from agent import db, execute_sql_query

def test_database_setup():
    """Test that the Chinook database is properly set up"""
    
    print("Testing Chinook Database Setup")
    print("=" * 40)
    
    test_queries = [
        ("Count artists", "SELECT COUNT(*) as artist_count FROM Artist"),
        ("Count albums", "SELECT COUNT(*) as album_count FROM Album"), 
        ("Count tracks", "SELECT COUNT(*) as track_count FROM Track"),
        ("Sample artists", "SELECT Name FROM Artist LIMIT 5"),
        ("Sample genres", "SELECT Name FROM Genre LIMIT 5"),
        ("Top tracks by price", "SELECT Name, UnitPrice FROM Track ORDER BY UnitPrice DESC LIMIT 3")
    ]
    
    for description, query in test_queries:
        print(f"\n{description}:")
        print(f"Query: {query}")
        try:
            result = execute_sql_query.func(query)
            print(f"Result: {result}")
        except Exception as e:
            print(f"Error: {e}")
    
    print(f"\nDatabase schema info available: {len(db.schema_info)} characters")

if __name__ == "__main__":
    test_database_setup()

