File Name: database.py

-----------------------------

File Content: 

import sqlite3
import requests
from typing import List, Dict, Any

class ChinookDatabase:
    def __init__(self):
        self.connection = None
        self.cursor = None
        
    def setup_database(self):
        """Fetch Chinook SQL and create in-memory database"""
        sql_url = "https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql"
        
        try:
            response = requests.get(sql_url)
            response.raise_for_status()
            sql_content = response.text
            
            self.connection = sqlite3.connect(":memory:")
            self.cursor = self.connection.cursor()
            
            self.cursor.executescript(sql_content)
            self.connection.commit()
            
            return True
        except Exception as e:
            print(f"Error setting up database: {e}")
            return False
    
    def get_table_schemas(self) -> Dict[str, List[Dict[str, Any]]]:
        """Extract detailed table schema information"""
        if not self.connection:
            return {}
            
        schemas = {}
        
        # Get all table names
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = self.cursor.fetchall()
        
        for table in tables:
            table_name = table[0]
            
            # Get column information
            self.cursor.execute(f"PRAGMA table_info({table_name});")
            columns = self.cursor.fetchall()
            
            schema_info = []
            for col in columns:
                schema_info.append({
                    'column_name': col[1],
                    'data_type': col[2],
                    'not_null': bool(col[3]),
                    'default_value': col[4],
                    'primary_key': bool(col[5])
                })
            
            schemas[table_name] = schema_info
        
        return schemas
    
    def execute_query(self, query: str) -> List[Dict[str, Any]]:
        """Execute SQL query and return results"""
        if not self.connection:
            return []
            
        try:
            self.cursor.execute(query)
            columns = [description[0] for description in self.cursor.description]
            rows = self.cursor.fetchall()
            
            results = []
            for row in rows:
                results.append(dict(zip(columns, row)))
            
            return results
        except Exception as e:
            print(f"Error executing query: {e}")
            return []
    
    def get_schema_description(self) -> str:
        """Get a formatted description of all table schemas"""
        schemas = self.get_table_schemas()
        description = "Database Schema:\n\n"
        
        for table_name, columns in schemas.items():
            description += f"Table: {table_name}\n"
            for col in columns:
                pk = " (PRIMARY KEY)" if col['primary_key'] else ""
                nn = " NOT NULL" if col['not_null'] else ""
                description += f"  - {col['column_name']}: {col['data_type']}{pk}{nn}\n"
            description += "\n"
        
        return description
    
    def close(self):
        """Close database connection"""
        if self.connection:
            self.connection.close()



File Name: main.py

-----------------------------

File Content: 

#!/usr/bin/env python3

from text_to_sql_agent import TextToSQLAgent
import os

def main():
    """Main function to test the text-to-SQL agent"""
    
    # Check if OpenAI API key is set
    if not os.getenv("OPENAI_API_KEY"):
        print("Please set your OPENAI_API_KEY environment variable")
        return
    
    try:
        # Initialize the agent
        print("Initializing Text-to-SQL Agent...")
        agent = TextToSQLAgent()
        print("Agent initialized successfully!")
        
        # Test queries
        test_queries = [
            "How many customers are there in total?",
            "What are the top 5 best-selling tracks?",
            "Which artist has the most albums?",
            "What is the average price of tracks?",
            "Show me all employees and their titles",
            "What is the weather like today?",  # Irrelevant query
            "How many invoices were created in 2009?"
        ]
        
        print("\n" + "="*50)
        print("Testing Text-to-SQL Agent")
        print("="*50)
        
        for i, query in enumerate(test_queries, 1):
            print(f"\nQuery {i}: {query}")
            print("-" * 40)
            
            try:
                response = agent.query(query)
                print(f"Response: {response}")
            except Exception as e:
                print(f"Error processing query: {e}")
        
        # Interactive mode
        print("\n" + "="*50)
        print("Interactive Mode (type 'quit' to exit)")
        print("="*50)
        
        while True:
            try:
                user_input = input("\nEnter your question: ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    break
                    
                if not user_input:
                    continue
                    
                response = agent.query(user_input)
                print(f"\nResponse: {response}")
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
        
        # Clean up
        agent.close()
        print("\nThank you for using the Text-to-SQL Agent!")
        
    except Exception as e:
        print(f"Failed to initialize agent: {e}")

if __name__ == "__main__":
    main()



File Name: text_to_sql_agent.py

-----------------------------

File Content: 

from typing import Dict, Any, List
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from database import ChinookDatabase
import os
from dotenv import load_dotenv
import json

load_dotenv()

class TextToSQLState:
    def __init__(self):
        self.user_question: str = ""
        self.generated_sql: str = ""
        self.query_results: List[Dict[str, Any]] = []
        self.natural_language_response: str = ""
        self.error: str = ""
        self.schema_info: str = ""

class TextToSQLAgent:
    def __init__(self, api_key: str = None):
        self.db = ChinookDatabase()
        self.llm = ChatOpenAI(
            api_key=api_key or os.getenv("OPENAI_API_KEY"),
            model="gpt-4-turbo-preview",
            temperature=0
        )
        self.setup_database()
        
    def setup_database(self):
        """Initialize the Chinook database"""
        if not self.db.setup_database():
            raise Exception("Failed to setup Chinook database")
    
    def text_to_sql_node(self, state: TextToSQLState) -> Dict[str, Any]:
        """Convert natural language question to SQL query"""
        schema_info = self.db.get_schema_description()
        
        system_prompt = f"""You are a SQL expert. Convert the user's natural language question into a valid SQLite query for the Chinook database.

{schema_info}

Rules:
1. Only generate SELECT queries - no INSERT, UPDATE, DELETE, DROP, etc.
2. If the question cannot be answered with the available tables, respond with "NO_ANSWER"
3. Return only the SQL query, nothing else
4. Use proper SQLite syntax
5. Be precise with table and column names
6. Use appropriate JOINs when needed

User Question: {state.user_question}

SQL Query:"""

        try:
            messages = [SystemMessage(content=system_prompt)]
            response = self.llm.invoke(messages)
            
            sql_query = response.content.strip()
            
            if sql_query == "NO_ANSWER" or "NO_ANSWER" in sql_query:
                state.error = "Cannot answer this question with the available data"
                state.generated_sql = ""
            else:
                state.generated_sql = sql_query
                state.schema_info = schema_info
                
        except Exception as e:
            state.error = f"Error generating SQL: {str(e)}"
            
        return {"state": state}
    
    def execute_sql_node(self, state: TextToSQLState) -> Dict[str, Any]:
        """Execute the generated SQL query"""
        if state.error or not state.generated_sql:
            return {"state": state}
            
        try:
            results = self.db.execute_query(state.generated_sql)
            state.query_results = results
        except Exception as e:
            state.error = f"Error executing SQL: {str(e)}"
            
        return {"state": state}
    
    def generate_response_node(self, state: TextToSQLState) -> Dict[str, Any]:
        """Generate natural language response from query results"""
        if state.error:
            state.natural_language_response = "I don't know the answer to that question."
            return {"state": state}
            
        if not state.query_results:
            state.natural_language_response = "No results found for your query."
            return {"state": state}
        
        system_prompt = f"""You are a helpful assistant that explains database query results in natural language.

User's original question: {state.user_question}
SQL query used: {state.generated_sql}
Query results: {json.dumps(state.query_results, indent=2)}

Provide a clear, concise answer to the user's question based on the query results. 
Be conversational and helpful. If there are multiple results, summarize appropriately.
Do not mention SQL queries or technical details unless relevant to the answer."""

        try:
            messages = [SystemMessage(content=system_prompt)]
            response = self.llm.invoke(messages)
            state.natural_language_response = response.content.strip()
        except Exception as e:
            state.natural_language_response = "I don't know the answer to that question."
            
        return {"state": state}
    
    def should_continue(self, state: TextToSQLState) -> str:
        """Determine next step in the workflow"""
        if state.error:
            return "generate_response"
        elif state.generated_sql and not state.query_results:
            return "execute_sql"
        elif state.query_results and not state.natural_language_response:
            return "generate_response"
        else:
            return END
    
    def create_workflow(self) -> StateGraph:
        """Create the LangGraph workflow"""
        workflow = StateGraph(TextToSQLState)
        
        # Add nodes
        workflow.add_node("text_to_sql", self.text_to_sql_node)
        workflow.add_node("execute_sql", self.execute_sql_node)
        workflow.add_node("generate_response", self.generate_response_node)
        
        # Define edges
        workflow.set_entry_point("text_to_sql")
        workflow.add_conditional_edges(
            "text_to_sql",
            self.should_continue,
            {
                "execute_sql": "execute_sql",
                "generate_response": "generate_response",
                END: END
            }
        )
        workflow.add_conditional_edges(
            "execute_sql",
            self.should_continue,
            {
                "generate_response": "generate_response",
                END: END
            }
        )
        workflow.add_edge("generate_response", END)
        
        return workflow.compile()
    
    def query(self, question: str) -> str:
        """Process a natural language question and return response"""
        state = TextToSQLState()
        state.user_question = question
        
        workflow = self.create_workflow()
        result = workflow.invoke({"state": state})
        
        return result["state"].natural_language_response
    
    def close(self):
        """Close database connection"""
        self.db.close()

